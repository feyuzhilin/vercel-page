import{V as _,b as at,P as oe,L as H,B as $,d as gt,G as ue,e as pe,f as de,M as he,g as ye,h as me,T as Ct,S as xe,i as bt,F as Ot,O as we,j as Ae,k as ge,D as be}from"./index.ac2cf653.js";var Pe=Object.defineProperty,Te=Object.defineProperties,Be=Object.getOwnPropertyDescriptors,qt=Object.getOwnPropertySymbols,Me=Object.prototype.hasOwnProperty,Se=Object.prototype.propertyIsEnumerable,Nt=(n,t,e)=>t in n?Pe(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,Bt=(n,t)=>{for(var e in t||(t={}))Me.call(t,e)&&Nt(n,e,t[e]);if(qt)for(var e of qt(t))Se.call(t,e)&&Nt(n,e,t[e]);return n},ve=(n,t)=>Te(n,Be(t));const re=0,Ie=1,_e=2,Ht=2,Mt=1.25,jt=1,wt=6*4+4+4,Vt=65535,Ce=Math.pow(2,-24);class ft{constructor(){}}function U(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function kt(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function Xt(n,t){t.set(n)}function Wt(n,t,e){let s,i;for(let r=0;r<3;r++){const o=r+3;s=n[r],i=t[r],e[r]=s<i?s:i,s=n[o],i=t[o],e[o]=s>i?s:i}}function ut(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],r=t[n+2*s+1],o=i-r,l=i+r;o<e[s]&&(e[s]=o),l>e[s+3]&&(e[s+3]=l)}}function et(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}function Ve(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;e>65535?i=new Uint32Array(new s(4*e)):i=new Uint16Array(new s(2*e)),n.setIndex(new bt(i,1));for(let r=0;r<e;r++)i[r]=r}}function Fe(n){if(!n.groups||!n.groups.length)return[{offset:0,count:n.index.count/3}];const t=[],e=new Set;for(const i of n.groups)e.add(i.start),e.add(i.start+i.count);const s=Array.from(e.values()).sort((i,r)=>i-r);for(let i=0;i<s.length-1;i++){const r=s[i],o=s[i+1];t.push({offset:r/3,count:(o-r)/3})}return t}function St(n,t,e,s,i=null){let r=1/0,o=1/0,l=1/0,c=-1/0,f=-1/0,a=-1/0,u=1/0,p=1/0,d=1/0,g=-1/0,w=-1/0,A=-1/0;const y=i!==null;for(let m=t*6,h=(t+e)*6;m<h;m+=6){const x=n[m+0],b=n[m+1],P=x-b,M=x+b;P<r&&(r=P),M>c&&(c=M),y&&x<u&&(u=x),y&&x>g&&(g=x);const B=n[m+2],T=n[m+3],S=B-T,v=B+T;S<o&&(o=S),v>f&&(f=v),y&&B<p&&(p=B),y&&B>w&&(w=B);const I=n[m+4],C=n[m+5],z=I-C,V=I+C;z<l&&(l=z),V>a&&(a=V),y&&I<d&&(d=I),y&&I>A&&(A=I)}s[0]=r,s[1]=o,s[2]=l,s[3]=c,s[4]=f,s[5]=a,y&&(i[0]=u,i[1]=p,i[2]=d,i[3]=g,i[4]=w,i[5]=A)}function ze(n,t,e,s){let i=1/0,r=1/0,o=1/0,l=-1/0,c=-1/0,f=-1/0;for(let a=t*6,u=(t+e)*6;a<u;a+=6){const p=n[a+0];p<i&&(i=p),p>l&&(l=p);const d=n[a+2];d<r&&(r=d),d>c&&(c=d);const g=n[a+4];g<o&&(o=g),g>f&&(f=g)}s[0]=i,s[1]=r,s[2]=o,s[3]=l,s[4]=c,s[5]=f}function Ee(n,t,e,s,i){let r=e,o=e+s-1;const l=i.pos,c=i.axis*2;for(;;){for(;r<=o&&t[r*6+c]<l;)r++;for(;r<=o&&t[o*6+c]>=l;)o--;if(r<o){for(let f=0;f<3;f++){let a=n[r*3+f];n[r*3+f]=n[o*3+f],n[o*3+f]=a;let u=t[r*6+f*2+0];t[r*6+f*2+0]=t[o*6+f*2+0],t[o*6+f*2+0]=u;let p=t[r*6+f*2+1];t[r*6+f*2+1]=t[o*6+f*2+1],t[o*6+f*2+1]=p}r++,o--}else return r}}const N=32,Le=(n,t)=>n.candidate-t.candidate,k=new Array(N).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),pt=new Float32Array(6);function Ue(n,t,e,s,i,r){let o=-1,l=0;if(r===re)o=kt(t),o!==-1&&(l=(t[o]+t[o+3])/2);else if(r===Ie)o=kt(n),o!==-1&&(l=De(e,s,i,o));else if(r===_e){const c=et(n);let f=Mt*i;const a=s*6,u=(s+i)*6;for(let p=0;p<3;p++){const d=t[p],A=(t[p+3]-d)/N;if(i<N/4){const y=[...k];y.length=i;let m=0;for(let x=a;x<u;x+=6,m++){const b=y[m];b.candidate=e[x+2*p],b.count=0;const{bounds:P,leftCacheBounds:M,rightCacheBounds:B}=b;for(let T=0;T<3;T++)B[T]=1/0,B[T+3]=-1/0,M[T]=1/0,M[T+3]=-1/0,P[T]=1/0,P[T+3]=-1/0;ut(x,e,P)}y.sort(Le);let h=i;for(let x=0;x<h;x++){const b=y[x];for(;x+1<h&&y[x+1].candidate===b.candidate;)y.splice(x+1,1),h--}for(let x=a;x<u;x+=6){const b=e[x+2*p];for(let P=0;P<h;P++){const M=y[P];b>=M.candidate?ut(x,e,M.rightCacheBounds):(ut(x,e,M.leftCacheBounds),M.count++)}}for(let x=0;x<h;x++){const b=y[x],P=b.count,M=i-b.count,B=b.leftCacheBounds,T=b.rightCacheBounds;let S=0;P!==0&&(S=et(B)/c);let v=0;M!==0&&(v=et(T)/c);const I=jt+Mt*(S*P+v*M);I<f&&(o=p,f=I,l=b.candidate)}}else{for(let h=0;h<N;h++){const x=k[h];x.count=0,x.candidate=d+A+h*A;const b=x.bounds;for(let P=0;P<3;P++)b[P]=1/0,b[P+3]=-1/0}for(let h=a;h<u;h+=6){let P=~~((e[h+2*p]-d)/A);P>=N&&(P=N-1);const M=k[P];M.count++,ut(h,e,M.bounds)}const y=k[N-1];Xt(y.bounds,y.rightCacheBounds);for(let h=N-2;h>=0;h--){const x=k[h],b=k[h+1];Wt(x.bounds,b.rightCacheBounds,x.rightCacheBounds)}let m=0;for(let h=0;h<N-1;h++){const x=k[h],b=x.count,P=x.bounds,B=k[h+1].rightCacheBounds;b!==0&&(m===0?Xt(P,pt):Wt(P,pt,pt)),m+=b;let T=0,S=0;m!==0&&(T=et(pt)/c);const v=i-m;v!==0&&(S=et(B)/c);const I=jt+Mt*(T*m+S*v);I<f&&(o=p,f=I,l=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:l}}function De(n,t,e,s){let i=0;for(let r=t,o=t+e;r<o;r++)i+=n[r*6+s*2];return i/e}function Re(n,t){const e=n.attributes.position,s=e.array,i=n.index.array,r=i.length/3,o=new Float32Array(r*6),l=e.offset||0;let c=3;e.isInterleavedBufferAttribute&&(c=e.data.stride);for(let f=0;f<r;f++){const a=f*3,u=f*6,p=i[a+0]*c+l,d=i[a+1]*c+l,g=i[a+2]*c+l;for(let w=0;w<3;w++){const A=s[p+w],y=s[d+w],m=s[g+w];let h=A;y<h&&(h=y),m<h&&(h=m);let x=A;y>x&&(x=y),m>x&&(x=m);const b=(x-h)/2,P=w*2;o[u+P+0]=h+b,o[u+P+1]=b+(Math.abs(h)+b)*Ce,h<t[w]&&(t[w]=h),x>t[w+3]&&(t[w+3]=x)}}return o}function Oe(n,t){function e(y){p&&p(y/d)}function s(y,m,h,x=null,b=0){if(!g&&b>=c&&(g=!0,f&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(n))),h<=a||b>=c)return e(m),y.offset=m,y.count=h,y;const P=Ue(y.boundingData,x,o,m,h,u);if(P.axis===-1)return e(m),y.offset=m,y.count=h,y;const M=Ee(l,o,m,h,P);if(M===m||M===m+h)e(m),y.offset=m,y.count=h;else{y.splitAxis=P.axis;const B=new ft,T=m,S=M-m;y.left=B,B.boundingData=new Float32Array(6),St(o,T,S,B.boundingData,r),s(B,T,S,r,b+1);const v=new ft,I=M,C=h-S;y.right=v,v.boundingData=new Float32Array(6),St(o,I,C,v.boundingData,r),s(v,I,C,r,b+1)}return y}Ve(n,t);const i=new Float32Array(6),r=new Float32Array(6),o=Re(n,i),l=n.index.array,c=t.maxDepth,f=t.verbose,a=t.maxLeafTris,u=t.strategy,p=t.onProgress,d=n.index.count/3;let g=!1;const w=[],A=Fe(n);if(A.length===1){const y=A[0],m=new ft;m.boundingData=i,ze(o,y.offset,y.count,r),s(m,y.offset,y.count,r),w.push(m)}else for(let y of A){const m=new ft;m.boundingData=new Float32Array(6),St(o,y.offset,y.count,m.boundingData,r),s(m,y.offset,y.count,r),w.push(m)}return w}function qe(n,t){const e=Oe(n,t);let s,i,r;const o=[],l=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<e.length;a++){const u=e[a];let p=c(u);const d=new l(wt*p);s=new Float32Array(d),i=new Uint32Array(d),r=new Uint16Array(d),f(0,u),o.push(d)}return o;function c(a){return a.count?1:1+c(a.left)+c(a.right)}function f(a,u){const p=a/4,d=a/2,g=!!u.count,w=u.boundingData;for(let A=0;A<6;A++)s[p+A]=w[A];if(g){const A=u.offset,y=u.count;return i[p+6]=A,r[d+14]=y,r[d+15]=Vt,a+wt}else{const A=u.left,y=u.right,m=u.splitAxis;let h;if(h=f(a+wt,A),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[p+6]=h/4,h=f(h,y),i[p+7]=m,h}}}class O{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let r=0,o=t.length;r<o;r++){const c=t[r][e];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let r=0,o=e.length;r<o;r++){const l=e[r],c=t.dot(l);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}O.prototype.setFromBox=function(){const n=new _;return function(e,s){const i=s.min,r=s.max;let o=1/0,l=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let a=0;a<=1;a++){n.x=i.x*c+r.x*(1-c),n.y=i.y*f+r.y*(1-f),n.z=i.z*a+r.z*(1-a);const u=e.dot(n);o=Math.min(u,o),l=Math.max(u,l)}this.min=o,this.max=l}}();(function(){const n=new O;return function(e,s){const i=e.points,r=e.satAxes,o=e.satBounds,l=s.points,c=s.satAxes,f=s.satBounds;for(let a=0;a<3;a++){const u=o[a],p=r[a];if(n.setFromPoints(p,l),u.isSeparated(n))return!1}for(let a=0;a<3;a++){const u=f[a],p=c[a];if(n.setFromPoints(p,i),u.isSeparated(n))return!1}}})();const Ne=function(){const n=new _,t=new _,e=new _;return function(i,r,o){const l=i.start,c=n,f=r.start,a=t;e.subVectors(l,f),n.subVectors(i.end,r.start),t.subVectors(r.end,r.start);const u=e.dot(a),p=a.dot(c),d=a.dot(a),g=e.dot(c),A=c.dot(c)*d-p*p;let y,m;A!==0?y=(u*p-g*d)/A:y=0,m=(u+y*p)/d,o.x=y,o.y=m}}(),Lt=function(){const n=new at,t=new _,e=new _;return function(i,r,o,l){Ne(i,r,n);let c=n.x,f=n.y;if(c>=0&&c<=1&&f>=0&&f<=1){i.at(c,o),r.at(f,l);return}else if(c>=0&&c<=1){f<0?r.at(0,l):r.at(1,l),i.closestPointToPoint(l,!0,o);return}else if(f>=0&&f<=1){c<0?i.at(0,o):i.at(1,o),r.closestPointToPoint(o,!0,l);return}else{let a;c<0?a=i.start:a=i.end;let u;f<0?u=r.start:u=r.end;const p=t,d=e;if(i.closestPointToPoint(u,!0,t),r.closestPointToPoint(a,!0,e),p.distanceToSquared(u)<=d.distanceToSquared(a)){o.copy(p),l.copy(u);return}else{o.copy(a),l.copy(d);return}}}}(),He=function(){const n=new _,t=new _,e=new oe,s=new H;return function(r,o){const{radius:l,center:c}=r,{a:f,b:a,c:u}=o;if(s.start=f,s.end=a,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l||(s.start=f,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l)||(s.start=a,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l))return!0;const w=o.getPlane(e);if(Math.abs(w.distanceToPoint(c))<=l){const y=w.projectPoint(c,t);if(o.containsPoint(y))return!0}return!1}}();class j extends Ct{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new _),this.satBounds=new Array(4).fill().map(()=>new O),this.points=[this.a,this.b,this.c],this.sphere=new xe,this.plane=new oe,this.needsUpdate=!1}intersectsSphere(t){return He(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,r=this.satAxes,o=this.satBounds,l=r[0],c=o[0];this.getNormal(l),c.setFromPoints(l,i);const f=r[1],a=o[1];f.subVectors(t,e),a.setFromPoints(f,i);const u=r[2],p=o[2];u.subVectors(e,s),p.setFromPoints(u,i);const d=r[3],g=o[3];d.subVectors(s,t),g.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const n=new _,t=new _,e=new H;return function(i,r=null,o=null){const{start:l,end:c}=i,f=this.points;let a,u=1/0;for(let p=0;p<3;p++){const d=(p+1)%3;e.start.copy(f[p]),e.end.copy(f[d]),Lt(e,i,n,t),a=n.distanceToSquared(t),a<u&&(u=a,r&&r.copy(n),o&&o.copy(t))}return this.closestPointToPoint(l,n),a=l.distanceToSquared(n),a<u&&(u=a,r&&r.copy(n),o&&o.copy(l)),this.closestPointToPoint(c,n),a=c.distanceToSquared(n),a<u&&(u=a,r&&r.copy(n),o&&o.copy(c)),Math.sqrt(u)}}();j.prototype.intersectsTriangle=function(){const n=new j,t=new Array(3),e=new Array(3),s=new O,i=new O,r=new _,o=new _,l=new _,c=new _,f=new H,a=new H,u=new H;return function(d,g=null){this.needsUpdate&&this.update(),d.isSeparatingAxisTriangle?d.needsUpdate&&d.update():(n.copy(d),n.update(),d=n);const w=this.satBounds,A=this.satAxes;e[0]=d.a,e[1]=d.b,e[2]=d.c;for(let h=0;h<4;h++){const x=w[h],b=A[h];if(s.setFromPoints(b,e),x.isSeparated(s))return!1}const y=d.satBounds,m=d.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let h=0;h<4;h++){const x=y[h],b=m[h];if(s.setFromPoints(b,t),x.isSeparated(s))return!1}for(let h=0;h<4;h++){const x=A[h];for(let b=0;b<4;b++){const P=m[b];if(r.crossVectors(x,P),s.setFromPoints(r,t),i.setFromPoints(r,e),s.isSeparated(i))return!1}}if(g){const h=this.plane,x=d.plane;if(Math.abs(h.normal.dot(x.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),g.start.set(0,0,0),g.end.set(0,0,0);else{const b=this.points;let P=!1;for(let T=0;T<3;T++){const S=b[T],v=b[(T+1)%3];if(f.start.copy(S),f.end.copy(v),x.intersectLine(f,P?a.start:a.end)){if(P)break;P=!0}}const M=d.points;let B=!1;for(let T=0;T<3;T++){const S=M[T],v=M[(T+1)%3];if(f.start.copy(S),f.end.copy(v),h.intersectLine(f,B?u.start:u.end)){if(B)break;B=!0}}if(a.delta(o),u.delta(l),o.dot(l)<0){let T=u.start;u.start=u.end,u.end=T}c.subVectors(a.start,u.start),c.dot(o)>0?g.start.copy(a.start):g.start.copy(u.start),c.subVectors(a.end,u.end),c.dot(o)<0?g.end.copy(a.end):g.end.copy(u.end)}}return!0}}();j.prototype.distanceToPoint=function(){const n=new _;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();j.prototype.distanceToTriangle=function(){const n=new _,t=new _,e=["a","b","c"],s=new H,i=new H;return function(o,l=null,c=null){const f=l||c?s:null;if(this.intersectsTriangle(o,f))return(l||c)&&(l&&f.getCenter(l),c&&f.getCenter(c)),0;let a=1/0;for(let u=0;u<3;u++){let p;const d=e[u],g=o[d];this.closestPointToPoint(g,n),p=g.distanceToSquared(n),p<a&&(a=p,l&&l.copy(n),c&&c.copy(g));const w=this[d];o.closestPointToPoint(w,n),p=w.distanceToSquared(n),p<a&&(a=p,l&&l.copy(w),c&&c.copy(n))}for(let u=0;u<3;u++){const p=e[u],d=e[(u+1)%3];s.set(this[p],this[d]);for(let g=0;g<3;g++){const w=e[g],A=e[(g+1)%3];i.set(o[w],o[A]),Lt(s,i,n,t);const y=n.distanceToSquared(t);y<a&&(a=y,l&&l.copy(n),c&&c.copy(t))}}return Math.sqrt(a)}}();class q extends ${constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new gt,this.invMatrix=new gt,this.points=new Array(8).fill().map(()=>new _),this.satAxes=new Array(3).fill().map(()=>new _),this.satBounds=new Array(3).fill().map(()=>new O),this.alignedSatBounds=new Array(3).fill().map(()=>new O),this.needsUpdate=!1}set(t,e,s){super.set(t,e),this.matrix=s,this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let f=0;f<=1;f++)for(let a=0;a<=1;a++)for(let u=0;u<=1;u++){const p=1*f|2*a|4*u,d=i[p];d.x=f?s.x:e.x,d.y=a?s.y:e.y,d.z=u?s.z:e.z,d.applyMatrix4(t)}const r=this.satBounds,o=this.satAxes,l=i[0];for(let f=0;f<3;f++){const a=o[f],u=r[f],p=1<<f,d=i[p];a.subVectors(l,d),u.setFromPoints(a,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const n=new O;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,r=this.satBounds,o=this.satAxes,l=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,l[0].isSeparated(n)||(n.min=s.y,n.max=i.y,l[1].isSeparated(n))||(n.min=s.z,n.max=i.z,l[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const f=o[c],a=r[c];if(n.setFromBox(f,e),a.isSeparated(n))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const n=new j,t=new Array(3),e=new O,s=new O,i=new _;return function(o){this.needsUpdate&&this.update(),o.isSeparatingAxisTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const l=this.satBounds,c=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let p=0;p<3;p++){const d=l[p],g=c[p];if(e.setFromPoints(g,t),d.isSeparated(e))return!1}const f=o.satBounds,a=o.satAxes,u=this.points;for(let p=0;p<3;p++){const d=f[p],g=a[p];if(e.setFromPoints(g,u),d.isSeparated(e))return!1}for(let p=0;p<3;p++){const d=c[p];for(let g=0;g<4;g++){const w=a[g];if(i.crossVectors(d,w),e.setFromPoints(i,t),s.setFromPoints(i,u),e.isSeparated(s))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();q.prototype.distanceToPoint=function(){const n=new _;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();q.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new H),e=new Array(12).fill().map(()=>new H),s=new _,i=new _;return function(o,l=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||f)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),c&&c.copy(s),f&&f.copy(i)),0;const a=l*l,u=o.min,p=o.max,d=this.points;let g=1/0;for(let A=0;A<8;A++){const y=d[A];i.copy(y).clamp(u,p);const m=y.distanceToSquared(i);if(m<g&&(g=m,c&&c.copy(y),f&&f.copy(i),m<a))return Math.sqrt(m)}let w=0;for(let A=0;A<3;A++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){const h=(A+1)%3,x=(A+2)%3,b=y<<h|m<<x,P=1<<A|y<<h|m<<x,M=d[b],B=d[P];t[w].set(M,B);const S=n[A],v=n[h],I=n[x],C=e[w],z=C.start,V=C.end;z[S]=u[S],z[v]=y?u[v]:p[v],z[I]=m?u[I]:p[v],V[S]=p[S],V[v]=y?u[v]:p[v],V[I]=m?u[I]:p[v],w++}for(let A=0;A<=1;A++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){i.x=A?p.x:u.x,i.y=y?p.y:u.y,i.z=m?p.z:u.z,this.closestPointToPoint(i,s);const h=i.distanceToSquared(s);if(h<g&&(g=h,c&&c.copy(s),f&&f.copy(i),h<a))return Math.sqrt(h)}for(let A=0;A<12;A++){const y=t[A];for(let m=0;m<12;m++){const h=e[m];Lt(y,h,s,i);const x=s.distanceToSquared(i);if(x<g&&(g=x,c&&c.copy(s),f&&f.copy(i),x<a))return Math.sqrt(x)}}return Math.sqrt(g)}}();const dt=new _,ht=new _,yt=new _,Gt=new at,$t=new at,Yt=new at,Zt=new _;function je(n,t,e,s,i,r){let o;return r===ge?o=n.intersectTriangle(s,e,t,!0,i):o=n.intersectTriangle(t,e,s,r!==be,i),o===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function ke(n,t,e,s,i,r,o){dt.fromBufferAttribute(t,s),ht.fromBufferAttribute(t,i),yt.fromBufferAttribute(t,r);const l=je(n,dt,ht,yt,Zt,o);if(l){e&&(Gt.fromBufferAttribute(e,s),$t.fromBufferAttribute(e,i),Yt.fromBufferAttribute(e,r),l.uv=Ct.getUV(Zt,dt,ht,yt,Gt,$t,Yt,new at));const c={a:s,b:i,c:r,normal:new _,materialIndex:0};Ct.getNormal(dt,ht,yt,c.normal),l.face=c,l.faceIndex=s}return l}function ce(n,t,e,s,i){const r=s*3,o=n.index.getX(r),l=n.index.getX(r+1),c=n.index.getX(r+2),f=ke(e,n.attributes.position,n.attributes.uv,o,l,c,t);return f?(f.faceIndex=s,i&&i.push(f),f):null}function Xe(n,t,e,s,i,r){for(let o=s,l=s+i;o<l;o++)ce(n,t,e,o,r)}function We(n,t,e,s,i){let r=1/0,o=null;for(let l=s,c=s+i;l<c;l++){const f=ce(n,t,e,l);f&&f.distance<r&&(o=f,r=f.distance)}return o}function ae(n,t,e){return n===null||(n.point.applyMatrix4(t.matrixWorld),n.distance=n.point.distanceTo(e.ray.origin),n.object=t,n.distance<e.near||n.distance>e.far)?null:n}function R(n,t,e,s){const i=n.a,r=n.b,o=n.c;let l=t,c=t+1,f=t+2;e&&(l=e.getX(t),c=e.getX(t+1),f=e.getX(t+2)),i.x=s.getX(l),i.y=s.getY(l),i.z=s.getZ(l),r.x=s.getX(c),r.y=s.getY(c),r.z=s.getZ(c),o.x=s.getX(f),o.y=s.getY(f),o.z=s.getZ(f)}function Kt(n,t,e,s,i,r,o){const l=e.index,c=e.attributes.position;for(let f=n,a=t+n;f<a;f++)if(R(o,f*3,l,c),o.needsUpdate=!0,s(o,f,i,r))return!0;return!1}class le{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function X(n,t){return t[n+15]===65535}function Q(n,t){return t[n+6]}function ot(n,t){return t[n+14]}function rt(n){return n+8}function ct(n,t){return t[n+6]}function Ge(n,t){return t[n+7]}const J=new $,Pt=new _,$e=["x","y","z"];function Ft(n,t,e,s,i){let r=n*2,o=tt,l=W,c=G;if(X(r,l)){const a=Q(n,c),u=ot(r,l);Xe(t,e,s,a,u,i)}else{const a=rt(n);Tt(a,o,s,Pt)&&Ft(a,t,e,s,i);const u=ct(n,c);Tt(u,o,s,Pt)&&Ft(u,t,e,s,i)}}function zt(n,t,e,s){let i=n*2,r=tt,o=W,l=G;if(X(i,o)){const f=Q(n,l),a=ot(i,o);return We(t,e,s,f,a)}else{const f=Ge(n,l),a=$e[f],p=s.direction[a]>=0;let d,g;p?(d=rt(n),g=ct(n,l)):(d=ct(n,l),g=rt(n));const A=Tt(d,r,s,Pt)?zt(d,t,e,s):null;if(A){const h=A.point[a];if(p?h<=r[g+f]:h>=r[g+f+3])return A}const m=Tt(g,r,s,Pt)?zt(g,t,e,s):null;return A&&m?A.distance<=m.distance?A:m:A||m||null}}const Ye=function(){let n,t;const e=[],s=new le(()=>new $);return function(...o){n=s.getPrimitive(),t=s.getPrimitive(),e.push(n,t);const l=i(...o);s.releasePrimitive(n),s.releasePrimitive(t),e.pop(),e.pop();const c=e.length;return c>0&&(t=e[c-1],n=e[c-2]),l};function i(r,o,l,c,f=null,a=0,u=0){function p(h){let x=h*2,b=W,P=G;for(;!X(x,b);)h=rt(h),x=h*2;return Q(h,P)}function d(h){let x=h*2,b=W,P=G;for(;!X(x,b);)h=ct(h,P),x=h*2;return Q(h,P)+ot(x,b)}let g=r*2,w=tt,A=W,y=G;if(X(g,A)){const h=Q(r,y),x=ot(g,A);return U(r,w,n),c(h,x,!1,u,a+r,n)}else{const h=rt(r),x=ct(r,y);let b=h,P=x,M,B,T,S;if(f&&(T=n,S=t,U(b,w,T),U(P,w,S),M=f(T),B=f(S),B<M)){b=x,P=h;const L=M;M=B,B=L,T=S}T||(T=n,U(b,w,T));const v=X(b*2,A),I=l(T,v,M,u+1,a+b);let C;if(I===Ht){const L=p(b),Z=d(b)-L;C=c(L,Z,!0,u+1,a+b,T)}else C=I&&i(b,o,l,c,f,a,u+1);if(C)return!0;S=t,U(P,w,S);const z=X(P*2,A),V=l(S,z,B,u+1,a+P);let E;if(V===Ht){const L=p(P),Z=d(P)-L;E=c(L,Z,!0,u+1,a+P,S)}else E=V&&i(P,o,l,c,f,a,u+1);return!!E}}}(),Ze=function(){const n=new j,t=new j,e=new gt,s=new q,i=new q;return function r(o,l,c,f,a=null){let u=o*2,p=tt,d=W,g=G;if(a===null&&(c.boundingBox||c.computeBoundingBox(),s.set(c.boundingBox.min,c.boundingBox.max,f),a=s),X(u,d)){const A=l,y=A.index,m=A.attributes.position,h=c.index,x=c.attributes.position,b=Q(o,g),P=ot(u,d);if(e.copy(f).invert(),c.boundsTree)return U(o,p,i),i.matrix.copy(e),i.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:B=>i.intersectsBox(B),intersectsTriangle:B=>{B.a.applyMatrix4(f),B.b.applyMatrix4(f),B.c.applyMatrix4(f),B.needsUpdate=!0;for(let T=b*3,S=(P+b)*3;T<S;T+=3)if(R(t,T,y,m),t.needsUpdate=!0,B.intersectsTriangle(t))return!0;return!1}});for(let M=b*3,B=P+b*3;M<B;M+=3){R(n,M,y,m),n.a.applyMatrix4(e),n.b.applyMatrix4(e),n.c.applyMatrix4(e),n.needsUpdate=!0;for(let T=0,S=h.count;T<S;T+=3)if(R(t,T,h,x),t.needsUpdate=!0,n.intersectsTriangle(t))return!0}}else{const A=o+8,y=g[o+6];return U(A,p,J),!!(a.intersectsBox(J)&&r(A,l,c,f,a)||(U(y,p,J),a.intersectsBox(J)&&r(y,l,c,f,a)))}}}();function Tt(n,t,e,s){return U(n,t,J),e.intersectBox(J,s)}const Et=[];let At,tt,W,G;function it(n){At&&Et.push(At),At=n,tt=new Float32Array(n),W=new Uint16Array(n),G=new Uint32Array(n)}function mt(){At=null,tt=null,W=null,G=null,Et.length&&it(Et.pop())}const vt=Symbol("skip tree generation"),It=new $,_t=new $,K=new gt,Y=new q,nt=new q,st=new _,xt=new _,Ke=new _,Je=new _,Qe=new _,Jt=new $,D=new le(()=>new j);class F{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),F.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e=Bt({cloneBuffers:!0},e);const s=t.geometry,i=t._roots,r=s.getIndex();let o;return e.cloneBuffers?o={roots:i.map(l=>l.slice()),index:r.array.slice()}:o={roots:i,index:r.array},o}static deserialize(t,e,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),F.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s=Bt({setIndex:!0},s);const{index:i,roots:r}=t,o=new F(e,ve(Bt({},s),{[vt]:!0}));if(o._roots=r,s.setIndex){const l=e.getIndex();if(l===null){const c=new bt(t.index,1,!1);e.setIndex(c)}else l.array!==i&&(l.array.set(i),l.needsUpdate=!0)}return o}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:re,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[vt]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer=="undefined")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[vt]||(this._roots=qe(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new $))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,s=e.index.array,i=e.attributes.position,r=i.array,o=i.offset||0;let l=3;i.isInterleavedBufferAttribute&&(l=i.data.stride);let c,f,a,u,p=0;const d=this._roots;for(let w=0,A=d.length;w<A;w++)c=d[w],f=new Uint32Array(c),a=new Uint16Array(c),u=new Float32Array(c),g(0,p),p+=c.byteLength;function g(w,A,y=!1){const m=w*2;if(a[m+15]===Vt){const x=f[w+6],b=a[m+14];let P=1/0,M=1/0,B=1/0,T=-1/0,S=-1/0,v=-1/0;for(let I=3*x,C=3*(x+b);I<C;I++){const z=s[I]*l+o,V=r[z+0],E=r[z+1],L=r[z+2];V<P&&(P=V),V>T&&(T=V),E<M&&(M=E),E>S&&(S=E),L<B&&(B=L),L>v&&(v=L)}return u[w+0]!==P||u[w+1]!==M||u[w+2]!==B||u[w+3]!==T||u[w+4]!==S||u[w+5]!==v?(u[w+0]=P,u[w+1]=M,u[w+2]=B,u[w+3]=T,u[w+4]=S,u[w+5]=v,!0):!1}else{const x=w+8,b=f[w+6],P=x+A,M=b+A;let B=y,T=!1,S=!1;t?B||(T=t.has(P),S=t.has(M),B=!T&&!S):(T=!0,S=!0);const v=B||T,I=B||S;let C=!1;v&&(C=g(x,A,B));let z=!1;I&&(z=g(b,A,B));const V=C||z;if(V)for(let E=0;E<3;E++){const L=x+E,lt=b+E,Z=u[L],Ut=u[L+3],Dt=u[lt],Rt=u[lt+3];u[w+E]=Z<Dt?Z:Dt,u[w+E+3]=Ut>Rt?Ut:Rt}return V}}}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),r=new Uint16Array(s);o(0);function o(l,c=0){const f=l*2,a=r[f+15]===Vt;if(a){const u=i[l+6],p=r[f+14];t(c,a,new Float32Array(s,l*4,6),u,p)}else{const u=l+wt/4,p=i[l+6],d=i[l+7];t(c,a,new Float32Array(s,l*4,6),d)||(o(u,c+1),o(p,c+1))}}}raycast(t,e=Ot){const s=this._roots,i=this.geometry,r=[],o=e.isMaterial,l=Array.isArray(e),c=i.groups,f=o?e.side:e;for(let a=0,u=s.length;a<u;a++){const p=l?e[c[a].materialIndex].side:f,d=r.length;if(it(s[a]),Ft(0,i,p,t,r),mt(),l){const g=c[a].materialIndex;for(let w=d,A=r.length;w<A;w++)r[w].face.materialIndex=g}}return r}raycastFirst(t,e=Ot){const s=this._roots,i=this.geometry,r=e.isMaterial,o=Array.isArray(e);let l=null;const c=i.groups,f=r?e.side:e;for(let a=0,u=s.length;a<u;a++){const p=o?e[c[a].materialIndex].side:f;it(s[a]);const d=zt(0,i,p,t);mt(),d!=null&&(l==null||d.distance<l.distance)&&(l=d,o&&(d.face.materialIndex=c[a].materialIndex))}return l}intersectsGeometry(t,e){const s=this.geometry;let i=!1;for(const r of this._roots)if(it(r),i=Ze(0,s,t,e),mt(),i)break;return i}shapecast(t,e,s){const i=this.geometry;if(t instanceof Function){if(e){const p=e;e=(d,g,w,A)=>{const y=g*3;return p(d,y,y+1,y+2,w,A)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=D.getPrimitive();let{boundsTraverseOrder:o,intersectsBounds:l,intersectsRange:c,intersectsTriangle:f}=t;if(c&&f){const p=c;c=(d,g,w,A,y)=>p(d,g,w,A,y)?!0:Kt(d,g,i,f,w,A,r)}else c||(f?c=(p,d,g,w)=>Kt(p,d,i,f,g,w,r):c=(p,d,g)=>g);let a=!1,u=0;for(const p of this._roots){if(it(p),a=Ye(0,i,l,c,o,u),mt(),a)break;u+=p.byteLength}return D.releasePrimitive(r),a}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const o=this.geometry.index,l=this.geometry.attributes.position,c=t.geometry.index,f=t.geometry.attributes.position;K.copy(e).invert();const a=D.getPrimitive(),u=D.getPrimitive();if(r){let d=function(g,w,A,y,m,h,x,b){for(let P=A,M=A+y;P<M;P++){R(u,P*3,c,f),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let B=g,T=g+w;B<T;B++)if(R(a,B*3,o,l),a.needsUpdate=!0,r(a,u,B,P,m,h,x,b))return!0}return!1};if(i){const g=i;i=function(w,A,y,m,h,x,b,P){return g(w,A,y,m,h,x,b,P)?!0:d(w,A,y,m,h,x,b,P)}}else i=d}this.getBoundingBox(_t),_t.applyMatrix4(e);const p=this.shapecast({intersectsBounds:d=>_t.intersectsBox(d),intersectsRange:(d,g,w,A,y,m)=>(It.copy(m),It.applyMatrix4(K),t.shapecast({intersectsBounds:h=>It.intersectsBox(h),intersectsRange:(h,x,b,P,M)=>i(d,g,h,x,A,y,P,M)}))});return D.releasePrimitive(a),D.releasePrimitive(u),p}intersectsBox(t,e){return Y.set(t.min,t.max,e),Y.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Y.intersectsBox(s),intersectsTriangle:s=>Y.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},r=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Y.set(t.boundingBox.min,t.boundingBox.max,e),Y.needsUpdate=!0;const l=this.geometry,c=l.attributes.position,f=l.index,a=t.attributes.position,u=t.index,p=D.getPrimitive(),d=D.getPrimitive();let g=xt,w=Ke,A=null,y=null;i&&(A=Je,y=Qe);let m=1/0,h=null,x=null;return K.copy(e).invert(),nt.matrix.copy(K),this.shapecast({boundsTraverseOrder:b=>Y.distanceToBox(b,Math.min(m,o)),intersectsBounds:(b,P,M)=>M<m&&M<o?(P&&(nt.min.copy(b.min),nt.max.copy(b.max),nt.needsUpdate=!0),!0):!1,intersectsRange:(b,P)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:M=>nt.distanceToBox(M,Math.min(m,o)),intersectsBounds:(M,B,T)=>T<m&&T<o,intersectsRange:(M,B)=>{for(let T=M*3,S=(M+B)*3;T<S;T+=3){R(d,T,u,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let v=b*3,I=(b+P)*3;v<I;v+=3){R(p,v,f,c),p.needsUpdate=!0;const C=p.distanceToTriangle(d,g,A);if(C<m&&(w.copy(g),y&&y.copy(A),m=C,h=v/3,x=T/3),C<r)return!0}}}});{const M=u?u.count:a.count;for(let B=0,T=M;B<T;B+=3){R(d,B,u,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let S=b*3,v=(b+P)*3;S<v;S+=3){R(p,S,f,c),p.needsUpdate=!0;const I=p.distanceToTriangle(d,g,A);if(I<m&&(w.copy(g),y&&y.copy(A),m=I,h=S/3,x=B/3),I<r)return!0}}}}}),D.releasePrimitive(p),D.releasePrimitive(d),m===1/0?null:(s.point?s.point.copy(w):s.point=w.clone(),s.distance=m,s.faceIndex=h,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(K),w.applyMatrix4(K),i.distance=w.sub(i.point).length(),i.faceIndex=x),s)}closestPointToPoint(t,e={},s=0,i=1/0){const r=s*s,o=i*i;let l=1/0,c=null;if(this.shapecast({boundsTraverseOrder:a=>(st.copy(t).clamp(a.min,a.max),st.distanceToSquared(t)),intersectsBounds:(a,u,p)=>p<l&&p<o,intersectsTriangle:(a,u)=>{a.closestPointToPoint(t,st);const p=t.distanceToSquared(st);return p<l&&(xt.copy(st),l=p,c=u),p<r}}),l===1/0)return null;const f=Math.sqrt(l);return e.point?e.point.copy(xt):e.point=xt.clone(),e.distance=f,e.faceIndex=c,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{U(0,new Float32Array(s),Jt),t.union(Jt)}),t}}const Qt=F.prototype.raycast;F.prototype.raycast=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[t,e,s,i]=n;return Qt.call(this,s,t.material).forEach(o=>{o=ae(o,t,e),o&&i.push(o)}),i}else return Qt.apply(this,n)};const te=F.prototype.raycastFirst;F.prototype.raycastFirst=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[t,e,s]=n;return ae(te.call(this,s,t.material),t,e)}else return te.apply(this,n)};const ee=F.prototype.closestPointToPoint;F.prototype.closestPointToPoint=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),n.unshift();const t=n[1],e={};return n[1]=e,ee.apply(this,n),t&&t.copy(e.point),e.distance}else return ee.apply(this,n)};const ne=F.prototype.closestPointToGeometry;F.prototype.closestPointToGeometry=function(...n){const t=n[2],e=n[3];if(t&&t.isVector3||e&&e.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const s={},i={},r=n[1];return n[2]=s,n[3]=i,ne.apply(this,n),t&&t.copy(s.point),e&&e.copy(i.point).applyMatrix4(r),s.distance}else return ne.apply(this,n)};const se=F.prototype.refit;F.prototype.refit=function(...n){const t=n[0],e=n[1];if(e&&(e instanceof Set||Array.isArray(e))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const s=new Set;e.forEach(i=>s.add(i)),t&&t.forEach(i=>s.add(i)),se.call(this,s)}else se.apply(this,n)};["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach(n=>{const t=F.prototype[n];F.prototype[n]=function(...e){return(e[0]===null||e[0].isMesh)&&(e.shift(),console.warn(`MeshBVH: The function signature for "${n}" has changed and no longer takes Mesh. See docs for new signature.`)),t.apply(this,e)}});const ie=new $;class tn extends we{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,s=10,i=0){super(),this.material=e,this.geometry=new Ae,this.name="MeshBVHRootVisualizer",this.depth=s,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=i}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,s=this._group;if(t.dispose(),this.visible=!1,e){const i=this.depth-1,r=this.displayParents;let o=0;e.traverse((p,d)=>{if(p===i||d)return o++,!0;r&&o++},s);let l=0;const c=new Float32Array(8*3*o);e.traverse((p,d,g)=>{const w=p===i||d;if(w||r){U(0,g,ie);const{min:A,max:y}=ie;for(let m=-1;m<=1;m+=2){const h=m<0?A.x:y.x;for(let x=-1;x<=1;x+=2){const b=x<0?A.y:y.y;for(let P=-1;P<=1;P+=2){const M=P<0?A.z:y.z;c[l+0]=h,c[l+1]=b,c[l+2]=M,l+=3}}}return w}},s);let f,a;this.displayEdges?a=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):a=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),c.length>65535?f=new Uint32Array(a.length*o):f=new Uint16Array(a.length*o);const u=a.length;for(let p=0;p<o;p++){const d=p*8,g=p*u;for(let w=0;w<u;w++)f[g+w]=d+a[w]}t.setIndex(new bt(f,1,!1)),t.setAttribute("position",new bt(c,3,!1)),this.visible=!0}}}class fe extends ue{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const s=new pe({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),i=new de({color:65416,transparent:!0,opacity:.3,depthWrite:!1});i.color=s.color,this.edgeMaterial=s,this.meshMaterial=i,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let s=0;s<e;s++){if(s>=this._roots.length){const r=new tn(this.mesh,this.edgeMaterial,this.depth,s);this.add(r),this._roots.push(r)}const i=this._roots[s];i.depth=this.depth,i.mesh=this.mesh,i.displayParents=this.displayParents,i.displayEdges=this.displayEdges,i.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,i.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new fe(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].geometry.dispose()}}he.prototype.raycast;const en=new WeakMap;var sn=n=>{n.outerObject3d.updateMatrixWorld(!0);const t=[];n.outerObject3d.traverse(s=>{if(!s.geometry||s===ye(n)&&!(n instanceof me))return;const i=s.geometry.clone();i.applyMatrix4(s.matrixWorld),t.push(i),i.dispose()});const e=[];for(const s of t){const i=s.boundsTree=new F(s);e.push(i),en.set(i,n)}return[e,t]};export{fe as M,en as b,sn as c};
